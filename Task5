# TASK 5: Implementation of Ant Colony Optimization (ACO)
# To Optimize Ride-Sharing Trip Duration

import numpy as np
from numpy import inf

# -------------------------------
#  Problem Data (Distance Matrix)
# -------------------------------
d = np.array([
    [0, 10, 12, 11, 14],
    [10, 0, 13, 15, 8],
    [12, 13, 0, 9, 14],
    [11, 15, 9, 0, 16],
    [14, 8, 14, 16, 0]
])

# -------------------------------
#  ACO Parameters
# -------------------------------
iteration = 100
n_ants = 5
n_citys = 5

m = n_ants          # Number of ants
n = n_citys         # Number of cities
e = 0.5             # Evaporation rate
alpha = 1           # Pheromone importance
beta = 2            # Visibility importance

# -------------------------------
#  Initialization
# -------------------------------
# Calculate visibility (1 / distance)
visibility = 1 / d
visibility[visibility == inf] = 0

# Initialize pheromone trail
pheromone = 0.1 * np.ones((m, n))

# Initialize route array (each antâ€™s path)
route = np.ones((m, n + 1))

# -------------------------------
#  Main ACO Algorithm
# -------------------------------
for ite in range(iteration):

    # Each ant starts at city 1
    route[:, 0] = 1

    for i in range(m):
        temp_visibility = np.array(visibility)

        for j in range(n - 1):
            combine_feature = np.zeros(5)
            cum_prob = np.zeros(5)

            cur_loc = int(route[i, j] - 1)
            temp_visibility[:, cur_loc] = 0

            # Calculate pheromone and visibility features
            p_feature = np.power(pheromone[cur_loc, :], beta)
            v_feature = np.power(temp_visibility[cur_loc, :], alpha)

            # Combine both features
            combine_feature = np.multiply(p_feature, v_feature)
            total = np.sum(combine_feature)
            probs = combine_feature / total

            # Calculate cumulative probability
            cum_prob = np.cumsum(probs)

            # Select next city
            r = np.random.random_sample()
            city = np.nonzero(cum_prob > r)[0][0] + 1
            route[i, j + 1] = city

        # Add the last remaining city
        left = list(set(range(1, n + 1)) - set(route[i, :-2]))[0]
        route[i, -2] = left

    # -------------------------------
    #  Distance Calculation
    # -------------------------------
    route_opt = np.array(route)
    dist_cost = np.zeros((m, 1))

    for i in range(m):
        s = 0
        for j in range(n - 1):
            s += d[int(route_opt[i, j]) - 1, int(route_opt[i, j + 1]) - 1]
        dist_cost[i] = s

    # Find the best (minimum distance) route
    dist_min_loc = np.argmin(dist_cost)
    dist_min_cost = dist_cost[dist_min_loc]
    best_route = route[dist_min_loc, :]

    # -------------------------------
    #  Pheromone Update
    # -------------------------------
    pheromone = (1 - e) * pheromone
    for i in range(m):
        for j in range(n - 1):
            delta = 1 / dist_cost[i]
            pheromone[int(route_opt[i, j]) - 1, int(route_opt[i, j + 1]) - 1] += delta

# -------------------------------
#  Final Output
# -------------------------------
print("Route of all ants at the end:")
print(route_opt)
print()
print("Best Path:", best_route)
print("Cost of the Best Path =", int(dist_min_cost[0]) + d[int(best_route[-2]) - 1, 0])
